// ЗАДАЧА DEV2
// Имеется числовой массив A заполненный числами из отрезка [minValue; maxValue]. 
// Создать на его основе масcив B, отбрасывая те, которые
// 1  нарушают порядок возрастания
// 2  элементы больше 8
// 3  нарушают порядок знакочередования

// ЗАДАЕМ МАССИВ
int[] A = new int[30]; // задаем количество элементов, изначально все элементы "0" по умолчанию
int index = 0; // определяем index (номер элемента в массиве) = 0

// ЗАПОЛНЯЕМ МАССИВ
while (index < 30) // указываем цикл, который будет выполняться, пока индекс меньше 30
{
    A[index] = new Random().Next(-100, 100);  // обращаемся к элементу Index в массиве A и присваиваем ему случ.число от -50 до 50
    index++; // прибавляем к значению index +1, пока index не станет больше 30, элементам будут присваиваться значения
}

index = 0; // обнуляем index, чтобы можно выполнить следующий цикл. Объявлять тип данных (int) второй раз уже не нужно!

// ПЕЧАТАЕМ МАССИВ
Console.WriteLine("Массив А: ");
while (index <= 19) // снова указываем цикл, но теперь вместо заполнения выводим результат
{
    Console.Write(A[index] + " ");  // выводим в терминал элементы массива (по очереди)
    index++; // прибавляем к значению index +1, пока index не станет больше 20, значения элементов будут выводиться в терминал
}

// ОТБРАСЫВАЕМ ЭЛЕМЕНТЫ, НАРУШАЮЩИЕ ПОРЯДОК ЗНАКОЧЕРЕДОВАНИЯ

Console.WriteLine(); // выводим в терминале пустую строку, чтобы был разрыв между масcивами
Console.WriteLine("Элементы массива, не нарушающие порядок знакочередования:");
Console.Write(A[0] + " ");                  // выводим в терминал первый элемент массива 
int current = A[0];                             // определяем первый текущий элемент
index = 1;                                  // определяем следующий элемент массива (по индексу)
for (index = 0; index < 30; index++)        // определяем цикл: для каждого следующего элемента массива, пока индекс меньше 20
                                            
    if (current < 0 && A[index] > 0)            //  первое условие: текущий элемент меньше 0 и следущий элемент больше 0
    {
        current = A[index];                     // если первое условие выполняется, то определяем новый текущий элемент
        Console.Write(current + " ");           // выводим новый текущий элемент на печать
        
    }
    else                                    // если первое условие не выполнено, то тогда:
        {
            if (current > 0 && A[index] < 0)    // второе условие: текущий элемент больше 0 и следующий элемент меньше 0
            {
                current = A[index];             // если второе условие выполняется, то определяем новый текущий элемент
                Console.Write(current + " ");   // выводим новый текущий элемент на печать
            }
        }

// // ИСКЛЮЧАЕМ ЭЛЕМЕНТЫ, НАРУШАЮЩИЕ ПОРЯДОК ВОЗРАСТАНИЯ И БОЛЬШЕ 8

Console.WriteLine(); // выводим в терминале пустую строку, чтобы был разрыв между масcивами
Console.WriteLine("Элементы, не нарушающие порядок возрастания и меньше 8:");
int currentElement = A[0]; // определям первый элемент, под индексом 0
if (A[0] < 8) // если элемент с индексом 0 и меньше 8 - выводим этот элемент в терминал
{
Console.WriteLine(currentElement); // выводим элемент в терминал (не нарушает порядок возрастания)
}

while (index <= 29) // снова указываем цикл, выводим результат
{
    if(A[index] > currentElement && A[index] < 8) // Больше ли значение элемента под текущим индексом значения первого элемента и меньше ли 8
    {
        Console.WriteLine(A[index]); // в случае, если значение больше, выводим значение элемента в терминал
        currentElement = A[index]; // если значение больше, присваиваем элементу currentElement значение под текущим индексом
        
    }

    index++; // прибавляем к значению index +1, пока index не станет равным 29, значения элементов будут выводиться в терминал

}
